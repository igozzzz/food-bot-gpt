"""
food_coach_bot_web.py
-----------------------------------------------
Telegram-Ğ±Ğ¾Ñ‚-Ğ½ÑƒÑ‚Ñ€Ğ¸Ñ†Ğ¸Ğ¾Ğ»Ğ¾Ğ³: Ğ¿Ñ€Ğ¸ÑÑ‹Ğ»Ğ°ĞµÑ‚Ğµ Ñ„Ğ¾Ñ‚Ğ¾ Ğ±Ğ»ÑĞ´Ğ° â€”
Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ + ĞšĞ‘Ğ–Ğ£ Ğ½Ğ° 100 Ğ³.

â€¢ PTB v21, FastAPI webhook
â€¢ OpenAI (gpt-4o) â€” Ğ¾Ñ‚Ğ²ĞµÑ‚ ÑÑ‚Ñ€Ğ¾Ğ³Ğ¾ Ğ² JSON
â€¢ Ğ¢Ñ€ĞµĞ±ÑƒĞµĞ¼Ñ‹Ğµ env-Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ: TELEGRAM_TOKEN, OPENAI_API_KEY, WEBHOOK_URL, PORT
"""

import os
import io
import json
import base64
import logging
from typing import Any, Dict

import httpx
import uvicorn
from dotenv import load_dotenv
from PIL import Image
from fastapi import FastAPI, Request
from telegram import Update, Bot
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    ContextTypes,
    filters,
)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ›ĞĞ“Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
)
log = logging.getLogger("food_bot")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ—ĞĞ“Ğ Ğ£Ğ—ĞšĞ ENV â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
load_dotenv()
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
WEBHOOK_URL    = os.getenv("WEBHOOK_URL")
PORT           = int(os.getenv("PORT", 8000))
MAX_FILE_SIZE  = 10 * 1024 * 1024  # 10 ĞœĞ‘

if not all([TELEGRAM_TOKEN, OPENAI_API_KEY, WEBHOOK_URL]):
    raise RuntimeError("ĞÑƒĞ¶Ğ½Ğ¾ Ğ·Ğ°Ğ´Ğ°Ñ‚ÑŒ TELEGRAM_TOKEN, OPENAI_API_KEY Ğ¸ WEBHOOK_URL Ğ² .env")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ›Ğ˜Ğ—ĞĞ¦Ğ˜Ğ¯ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bot = Bot(token=TELEGRAM_TOKEN)
app = FastAPI()
application = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

import openai
openai_client = openai.AsyncOpenAI(
    api_key=OPENAI_API_KEY,
    http_client=httpx.AsyncClient(timeout=30.0),
)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HELPER Ğ”Ğ›Ğ¯ OpenAI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def analyse_image(img_b64: str) -> Dict[str, Any]:
    """
    ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ°Ñ€Ñ‚Ğ¸Ğ½ĞºÑƒ, Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ dict Ñ Ğ¿Ğ¾Ğ»ÑĞ¼Ğ¸:
    dish, calories, protein, fat, carbs.
    """
    resp = await openai_client.chat.completions.create(
        model="gpt-4o",
        response_format={"type": "json_object"},  # Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠĞµĞºÑ‚
        temperature=0.2,
        max_tokens=200,
        messages=[
            {
                "role": "system",
                "content": (
                    "Ğ¢Ñ‹ Ğ½ÑƒÑ‚Ñ€Ğ¸Ñ†Ğ¸Ğ¾Ğ»Ğ¾Ğ³. Ğ’ĞµÑ€Ğ½Ğ¸ JSON-Ğ¾Ğ±ÑŠĞµĞºÑ‚ Ñ ĞºĞ»ÑÑ‡Ğ°Ğ¼Ğ¸: "
                    "dish, calories, protein, fat, carbs. "
                    "Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ â€” Ğ½Ğ° 100 Ğ³. Ğ•ÑĞ»Ğ¸ Ğ½Ğµ ÑƒĞ²ĞµÑ€ĞµĞ½ â€” ÑÑ‚Ğ°Ğ²ÑŒ â€œâ€”â€."
                ),
            },
            {
                "role": "user",
                "content": [
                    {
                        "type": "image_url",
                        "image_url": {"url": f"data:image/jpeg;base64,{img_b64}"},
                    },
                    {"type": "text", "text": "ĞŸÑ€Ğ¾Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞ¹ Ğ±Ğ»ÑĞ´Ğ¾ Ğ½Ğ° Ñ„Ğ¾Ñ‚Ğ¾."},
                ],
            },
        ],
    )
    # ĞŸĞ°Ñ€ÑĞ¸Ğ¼ ÑÑ‚Ñ€Ğ¾ĞºÑƒ JSON Ğ² dict
    return json.loads(resp.choices[0].message.content)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HANDLERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def cmd_start(update: Update, ctx: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(
        "ğŸ‘‹ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! ĞŸÑ€Ğ¸ÑˆĞ»Ğ¸ Ñ„Ğ¾Ñ‚Ğ¾ Ğ±Ğ»ÑĞ´Ğ° â€” ÑĞºĞ°Ğ¶Ñƒ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸ ĞšĞ‘Ğ–Ğ£ Ğ½Ğ° 100 Ğ³."
    )

async def handle_photo(update: Update, ctx: ContextTypes.DEFAULT_TYPE) -> None:
    try:
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ñ„Ğ¾Ñ‚Ğ¾
        photos = update.message.photo
        if not photos:
            return
        photo = photos[-1]  # Ğ±ĞµÑ€Ñ‘Ğ¼ ÑĞ°Ğ¼ÑƒÑ Ğ±Ğ¾Ğ»ÑŒÑˆÑƒÑ Ğ¿Ñ€ĞµĞ²ÑŒÑ
        if photo.file_size and photo.file_size > MAX_FILE_SIZE:
            return await update.message.reply_text("âš ï¸ Ğ¤Ğ¾Ñ‚Ğ¾ > 10 ĞœĞ‘, Ğ¿Ñ€Ğ¸ÑˆĞ»Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ¼ĞµĞ½ÑŒÑˆĞµ.")

        # Ğ¡ĞºĞ°Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ„Ğ°Ğ¹Ğ» Ğ² Ğ±ÑƒÑ„ĞµÑ€
        tg_file = await photo.get_file()
        buf = io.BytesIO()
        await tg_file.download_to_memory(out=buf)
        raw = buf.getvalue()

        # ĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° base64
        image = Image.open(io.BytesIO(raw)).convert("RGB")
        buf2 = io.BytesIO()
        image.save(buf2, format="JPEG", quality=85)
        img_b64 = base64.b64encode(buf2.getvalue()).decode()

        await update.message.reply_text("ğŸ¤– ĞĞ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒÑ Ñ„Ğ¾Ñ‚Ğ¾â€¦")

        # Ğ—Ğ°Ğ¿Ñ€Ğ¾Ñ Ğº OpenAI
        try:
            data = await analyse_image(img_b64)
        except Exception as e:
            log.error("OpenAI error:", exc_info=e)
            return await update.message.reply_text("âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘.")

        # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¾Ñ‚Ğ²ĞµÑ‚
        dish = data.get("dish", "â€”")
        cal  = data.get("calories", "â€”")
        prot = data.get("protein", "â€”")
        fat  = data.get("fat", "â€”")
        carb = data.get("carbs", "â€”")

        await update.message.reply_text(
            f"ğŸ½ {dish}\n"
            f"ğŸ”¥ {cal} ĞºĞºĞ°Ğ» / 100 Ğ³\n"
            f"ğŸ¥© {prot} Ğ³   ğŸ¥‘ {fat} Ğ³   ğŸ {carb} Ğ³"
        )

    except Exception as e:
        log.error("Handle photo error:", exc_info=e)
        await update.message.reply_text("âš ï¸ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ Ñ„Ğ¾Ñ‚Ğ¾. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ.")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ĞŸĞĞ”Ğ’Ğ¯Ğ—ĞšĞ HANDLERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
application.add_handler(CommandHandler("start", cmd_start))
application.add_handler(MessageHandler(filters.PHOTO, handle_photo))

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FASTAPI WEBHOOK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@app.post("/", status_code=200)
async def telegram_webhook(req: Request) -> dict:
    payload = await req.json()
    if not getattr(application, "_initialized", False):
        await application.initialize()
    update = Update.de_json(payload, bot)
    await application.process_update(update)
    return {"ok": True}

@app.get("/")
async def root() -> dict:
    return {"status": "alive"}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ START / SHUTDOWN EVENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@app.on_event("startup")
async def on_startup():
    await application.initialize()
    await bot.set_webhook(WEBHOOK_URL, drop_pending_updates=True)
    log.info("Webhook ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½: %s", WEBHOOK_URL)

@app.on_event("shutdown")
async def on_shutdown():
    await bot.delete_webhook()
    await application.shutdown()
    log.info("Webhook ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½, Ğ±Ğ¾Ñ‚ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Ğ›ĞĞšĞĞ›Ğ¬ĞĞ«Ğ™ Ğ—ĞĞŸĞ£Ğ¡Ğš â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if __name__ == "__main__":
    uvicorn.run("food_coach_bot_web:app", host="0.0.0.0", port=PORT)
